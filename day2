类的三个组成成分：属性 构造器（custructor） 方法

属性：成员变量 & 局部变量
      成员变量：声明在类里面，方法外面（public protected 缺省 private）
      局部变量：声明在方法内，方法的形参部分，代码块内（没有修饰符，与所在方法的修饰符相同）
      
      数据类型（8种基本数据类型&引用数据类型）
      成员变量初始化值： byte short int long ==> 0
                float double ==> 0.0
                char  ==> 空格
                boolean ==> false
                引用数据类型 ==> null
      局部变量一定要显示的赋值（没有默认的初始化值）
      内存中的位置：（成员变量存在于堆空间中，局部变量存在于栈空间中）
      
总结：关于变量的分类：1）按照数据类型的不同：基本数据类型（8种）  & 引用数据类型
          			   2）按照声明的位置的不同：成员变量 & 局部变量
                  
*内存划分的结构：
      栈（stack）：局部变量、对象的引用名、数组的引用名
      堆（heap）：new出来的（对象的实体或数组的实体）、成员变量
      方法区：含字符串常量
      静态域：声明有static的变量
      eg. Person p = new Person();//p是对象Person的引用名，存在于栈空间中，Person（）是对象的实体，存在于堆空间中，p存储Person（）的空间地址
          public void setName(int x){int temp = x;};//x是方法的形参，temp是声明在方法内的变量，都是局部变量，存在于栈空间中，方法调用完后被回收
          
方法的重载（overload）
    要求： 1.同一个类中 2.方法名必须相同 3.方法的参数列表不同（参数的个数不同 || 参数类型不同）
    补充：方法的重载与方法的返回值类型没有关系！
    eg. 下面的两个方法构成重载：
    public void method1(int i,String str){
	  }
    public void method1(String str1,int j){
	  } 
    
 * 可变个数的形参的方法：
 * 1.格式：对于方法的形参： 数据类型 ... 形参名
 * 2.可变个数的形参的方法与同名的方法之间构成重载
 * 3.可变个数的形参在调用时，个数从0开始，到无穷多个都可以。
 * 4.使用可变多个形参的方法与方法的形参使用数组是一致的。
 * 5.在一个方法中，最多声明一个可变个数的形参，而且要声明在方法的形参的最后。//若放在前面，程序无法判断可变个数形参的个数，从而出错
 eg.
 	public void sayHello(int i,String ... args){
	//public void sayHello(String ... args,int i){ 这种写法是错误的，应该把可变个数形参放在最后
		System.out.println(i);
		for(int j = 0;j < args.length;j++){
			System.out.println(args[j] + "$");
		}
	}
    
★java的值传递
 * 1.形参：方法声明时，方法小括号内的参数
 *   实参：调用方法时，实际传入的参数的值
 *   
 * 2.规则：java中的参数传递机制：值传递机制
 *   1）形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量
 *   2）形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。

 
 面对对象的特征一：封装和隐藏
 * 问题：当创建了类的对象以后，如果直接通过"对象.属性"的方式对相应的对象属性赋值的话，可能会出现不满足实际
 * 情况的意外，我们考虑不让对象来直接作用属性，而是通过"对象.方法"的形式，来控制对象对属性的访问。实际
 * 情况中，对属性的要求就可以通过方法来体现。
 
面向对象思想的操作：
（封装性的思想） 1.将类的属性私有化
                2.提供公共的方法（setter & getter）来实现调用。

四种权限修饰符
1.权限从大到小为：               public   protected      缺省            private 
   四种权限对应的访问限制：      任何地方   + 子类      + 同一个包          类内部
2.四种权限都可以用来修饰属性、方法、构造器
3.类（class）只可以用public和defaul（缺省）来修饰//public类可以在任意地方被访问，default类只可以被同一个包中内部的类访问。


构造器：//Person p = new Person(); 这里的Person（）是一个构造器，所以是new了一个构造器而不是new了一个类
    作用：1.创建对象 2.给创建的对象的属性赋值
    补充: 1.设计类时，若不显式声明类的构造器的话，程序会默认提供一个空参的构造器.
          2.一旦显式的定义类的构造器，那么默认的构造器就不再提供。
          3.如何声明类的构造器。格式：权限修饰符  类名(形参){ }
          4.类的多个构造器之间构成重载
          
    类对象的属性赋值的先后顺序：1.属性的默认初始化2.属性的显式初始化3.通过构造器给属性初始化 4.通过"对象.方法"的方式给属性赋值




 
 
 
 
 
 
 
 
 
 
 
